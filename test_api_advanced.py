#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Script de Teste Avan√ßado da API Decision Recruitment AI
Testa todos os endpoints com valida√ß√£o de respostas
"""

import requests
import json
import time
from datetime import datetime
from typing import Dict, Any, List

class APITester:
    def __init__(self, base_url: str = "http://localhost:8000"):
        self.base_url = base_url.rstrip('/')
        self.session = requests.Session()
        self.results = []

    def test_endpoint(self, method: str, endpoint: str, data: Dict = None, 
                     expected_status: int = 200, description: str = "") -> Dict[str, Any]:
        """Testa um endpoint espec√≠fico"""
        url = f"{self.base_url}{endpoint}"
        
        print(f"\nüîç Testando: {description}")
        print(f"   {method} {url}")
        
        try:
            if method.upper() == "GET":
                response = self.session.get(url, timeout=10)
            elif method.upper() == "POST":
                response = self.session.post(
                    url, 
                    json=data, 
                    headers={"Content-Type": "application/json"},
                    timeout=10
                )
            else:
                raise ValueError(f"M√©todo HTTP n√£o suportado: {method}")
            
            # Verificar status code
            status_ok = response.status_code == expected_status
            status_icon = "‚úÖ" if status_ok else "‚ùå"
            
            print(f"   Status: {status_icon} {response.status_code}")
            
            # Tentar parsear JSON
            try:
                response_data = response.json()
                print(f"   Resposta: {json.dumps(response_data, indent=2, ensure_ascii=False)}")
            except:
                print(f"   Resposta (texto): {response.text[:200]}...")
                response_data = None
            
            result = {
                "endpoint": endpoint,
                "method": method,
                "description": description,
                "status_code": response.status_code,
                "expected_status": expected_status,
                "success": status_ok,
                "response_data": response_data,
                "timestamp": datetime.now().isoformat()
            }
            
            if status_ok:
                print(f"   ‚úÖ Teste passou!")
            else:
                print(f"   ‚ùå Teste falhou! Esperado: {expected_status}")
            
            return result
            
        except requests.exceptions.RequestException as e:
            print(f"   ‚ùå Erro de conex√£o: {e}")
            return {
                "endpoint": endpoint,
                "method": method,
                "description": description,
                "status_code": None,
                "expected_status": expected_status,
                "success": False,
                "error": str(e),
                "timestamp": datetime.now().isoformat()
            }
        except Exception as e:
            print(f"   ‚ùå Erro inesperado: {e}")
            return {
                "endpoint": endpoint,
                "method": method,
                "description": description,
                "status_code": None,
                "expected_status": expected_status,
                "success": False,
                "error": str(e),
                "timestamp": datetime.now().isoformat()
            }

    def test_health_endpoint(self):
        """Testa endpoint de health check"""
        return self.test_endpoint(
            "GET", 
            "/health", 
            description="Health Check"
        )

    def test_model_info_endpoint(self):
        """Testa endpoint de informa√ß√µes do modelo"""
        return self.test_endpoint(
            "GET", 
            "/model_info", 
            description="Informa√ß√µes do Modelo"
        )

    def test_feature_importance_endpoint(self):
        """Testa endpoint de import√¢ncia das features"""
        return self.test_endpoint(
            "GET", 
            "/feature_importance", 
            description="Import√¢ncia das Features"
        )

    def test_mlflow_info_endpoint(self):
        """Testa endpoint de informa√ß√µes MLflow"""
        return self.test_endpoint(
            "GET", 
            "/mlflow_info", 
            description="Informa√ß√µes MLflow"
        )

    def test_predict_endpoint(self):
        """Testa endpoint de predi√ß√£o"""
        test_data = {
            "candidate": {
                "nome": "Jo√£o Silva",
                "nivel_profissional_candidato": "S√™nior",
                "nivel_ingles_candidato": "Avan√ßado",
                "nivel_espanhol_candidato": "Intermedi√°rio",
                "cv_text": "Desenvolvedor Python com 5 anos de experi√™ncia em Django, Flask, AWS, Docker. Especialista em machine learning e an√°lise de dados.",
                "pcd": "N√£o",
                "remuneracao": 8000.0,
                "estado": "S√£o Paulo"
            },
            "job": {
                "titulo_vaga": "Desenvolvedor Python S√™nior",
                "nivel_profissional_vaga": "S√™nior",
                "nivel_ingles_vaga": "Avan√ßado",
                "nivel_espanhol_vaga": "B√°sico",
                "vaga_sap": "N√£o",
                "competencia_tecnicas": "Python, Django, Flask, AWS, Docker",
                "tipo_contratacao": "CLT Full"
            }
        }
        
        return self.test_endpoint(
            "POST", 
            "/predict", 
            data=test_data,
            description="Predi√ß√£o Individual"
        )

    def test_batch_predict_endpoint(self):
        """Testa endpoint de predi√ß√£o em lote"""
        test_data = {
            "candidates": [
                {
                    "nome": "Maria Santos",
                    "nivel_profissional_candidato": "Pleno",
                    "nivel_ingles_candidato": "Intermedi√°rio",
                    "nivel_espanhol_candidato": "B√°sico",
                    "cv_text": "Desenvolvedora Java com 3 anos de experi√™ncia. Conhecimento em Spring Boot, MySQL, Git.",
                    "pcd": "N√£o",
                    "remuneracao": 6000.0,
                    "estado": "Rio de Janeiro"
                },
                {
                    "nome": "Pedro Costa",
                    "nivel_profissional_candidato": "J√∫nior",
                    "nivel_ingles_candidato": "B√°sico",
                    "nivel_espanhol_candidato": "Nenhum",
                    "cv_text": "Estudante de Ci√™ncia da Computa√ß√£o. Conhecimento b√°sico em Python, HTML, CSS.",
                    "pcd": "N√£o",
                    "remuneracao": 3000.0,
                    "estado": "Minas Gerais"
                }
            ],
            "job": {
                "titulo_vaga": "Desenvolvedor Java Pleno",
                "nivel_profissional_vaga": "Pleno",
                "nivel_ingles_vaga": "Intermedi√°rio",
                "nivel_espanhol_vaga": "Nenhum",
                "vaga_sap": "N√£o",
                "competencia_tecnicas": "Java, Spring Boot, MySQL, Git",
                "tipo_contratacao": "CLT Full"
            }
        }
        
        return self.test_endpoint(
            "POST", 
            "/predict_batch", 
            data=test_data,
            description="Predi√ß√£o em Lote"
        )

    def run_all_tests(self):
        """Executa todos os testes"""
        print("üöÄ INICIANDO TESTES AVAN√áADOS DA API")
        print("=" * 60)
        print(f"üåê URL Base: {self.base_url}")
        print(f"‚è∞ In√≠cio: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        
        start_time = time.time()
        
        # Lista de testes
        tests = [
            self.test_health_endpoint,
            self.test_model_info_endpoint,
            self.test_feature_importance_endpoint,
            self.test_mlflow_info_endpoint,
            self.test_predict_endpoint,
            self.test_batch_predict_endpoint
        ]
        
        # Executar testes
        for test_func in tests:
            try:
                result = test_func()
                self.results.append(result)
            except Exception as e:
                print(f"‚ùå Erro ao executar teste {test_func.__name__}: {e}")
                self.results.append({
                    "test_function": test_func.__name__,
                    "success": False,
                    "error": str(e),
                    "timestamp": datetime.now().isoformat()
                })
            
            # Pequena pausa entre testes
            time.sleep(0.5)
        
        end_time = time.time()
        duration = end_time - start_time
        
        # Relat√≥rio final
        self.print_summary(duration)
        
        return self.results

    def print_summary(self, duration: float):
        """Imprime resumo dos testes"""
        print("\n" + "=" * 60)
        print("üìä RESUMO DOS TESTES")
        print("=" * 60)
        
        total_tests = len(self.results)
        successful_tests = sum(1 for r in self.results if r.get("success", False))
        failed_tests = total_tests - successful_tests
        
        print(f"‚è±Ô∏è  Dura√ß√£o total: {duration:.2f} segundos")
        print(f"üìà Total de testes: {total_tests}")
        print(f"‚úÖ Testes bem-sucedidos: {successful_tests}")
        print(f"‚ùå Testes falharam: {failed_tests}")
        print(f"üìä Taxa de sucesso: {(successful_tests/total_tests*100):.1f}%")
        
        # Detalhes dos testes
        print(f"\nüìã DETALHES DOS TESTES:")
        print("-" * 40)
        
        for result in self.results:
            status_icon = "‚úÖ" if result.get("success", False) else "‚ùå"
            description = result.get("description", "Teste sem descri√ß√£o")
            status_code = result.get("status_code", "N/A")
            
            print(f"{status_icon} {description} - Status: {status_code}")
            
            if not result.get("success", False) and "error" in result:
                print(f"   üí• Erro: {result['error']}")
        
        # Salvar resultados
        self.save_results()

    def save_results(self):
        """Salva resultados em arquivo JSON"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"test_results_{timestamp}.json"
        
        try:
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump({
                    "test_summary": {
                        "timestamp": datetime.now().isoformat(),
                        "base_url": self.base_url,
                        "total_tests": len(self.results),
                        "successful_tests": sum(1 for r in self.results if r.get("success", False)),
                        "failed_tests": len(self.results) - sum(1 for r in self.results if r.get("success", False))
                    },
                    "test_results": self.results
                }, f, indent=2, ensure_ascii=False)
            
            print(f"\nüíæ Resultados salvos em: {filename}")
            
        except Exception as e:
            print(f"‚ùå Erro ao salvar resultados: {e}")

def main():
    """Fun√ß√£o principal"""
    import sys
    
    # URL base (padr√£o ou argumento)
    base_url = "http://localhost:8000"
    if len(sys.argv) > 1:
        base_url = sys.argv[1]
    
    print("Decision Recruitment AI - Teste Avan√ßado da API")
    print("=" * 50)
    print(f"üåê Testando API em: {base_url}")
    
    # Criar tester e executar testes
    tester = APITester(base_url)
    results = tester.run_all_tests()
    
    # Verificar se todos os testes passaram
    all_passed = all(r.get("success", False) for r in results)
    
    if all_passed:
        print("\nüéâ TODOS OS TESTES PASSARAM!")
        sys.exit(0)
    else:
        print("\n‚ö†Ô∏è  ALGUNS TESTES FALHARAM!")
        sys.exit(1)

if __name__ == "__main__":
    main()
